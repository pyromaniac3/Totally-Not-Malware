// Starter code provided by https://github.com/tanhauhau/browser-pet/tree/master
let hunger = 0
let attention = 0
let WILL_KNOCK = false;
const position = {
    x: 0,
    y: 0,
};
let isSwatting = false;
//#region ONLOAD
function onload() {
  // check if we are in the extension popup or the webpage
  

  //create pet
  const pet = document.createElement('div');
  pet.classList.add('meowware-pet');
  document.body.appendChild(pet);
  console.log("Loaded tamagotchi.js");

  //create food
  const food = document.createElement('div');
  food.classList.add('meowware-food');

  feedBut = document.getElementById('feedMe');
  if (feedBut != null) {
    feedBut.addEventListener('click', function() {
      console.log('Feed Button clicked!');
      spawnFood(food, pet);
    });
  }
  /*
  function playButtonClick() {
    console.log('Play Button clicked!');
  }

  function fakeQuitButtonClick() {
    console.log('Fake Quit Button clicked!');
    window.close();
  }
  */

  // Randomly reposition the pet every few seconds
  setInterval(() => {
    repositionPet(pet);
  }, 3000); // Adjust the interval (in milliseconds) as needed

  // Check if we should play a knock every 30 seconds.
  setInterval(() => {
    check_if_knock();
  }, 30000);

  

  pet.classList.add('allow="autoplay"');

  // Creating a second div to be able to Ctrl+F in DOM.
  const identifier_div = document.createElement('div');
  identifier_div.classList.add('meowware-pet');
  pet.appendChild(identifier_div);

  textEles = textNodesUnder(document);
  setInterval(() => {
      feedMeText(textEles);
    }, 50000);
  //feedMeText(textEles);
  //eatAllTextPage(textEles);
  //eatEntirePage();
  console.log("Attached identifier to be able to more easily attach.")

  document.getElementById('feedMe').addEventListener('click', function() {
      if (hunger >= 10) {
        hunger -= 10;
      }
      console.log('Feed Button clicked!');
    });
  document.getElementById('playMe').addEventListener('click', function() {
      if (attention >= 10) {
        attention -= 10;
      }
      console.log('Play Button clicked!');
    });
  document.getElementById('fakeQuit').addEventListener('click', function() {
      console.log('Fake Quit Button clicked!');
    });
  
  setInterval(updateStats, 60000)
} 
window.addEventListener('load', onload);
//#endregion
// END OF ONLOAD FUNCTION

//#region ---------------- POSITION/MOVING -------------------
function updatePosition(pet, x, y) {
  pet.style.left = (position.x = x) + 'px';
  pet.style.top = (position.y = y) + 'px'; 
}
function random(max) {
  return Math.floor(Math.random() * max);
}

function repositionPet(pet) {
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;

  // Calculate random positions within the screen dimensions
  const newPosition = { x: random(screenWidth), y: random(screenHeight) };
  const oldPosition = { x: position.x, y: position.y };

  let i = 0;
  const interval = setInterval(() => {
      const lerpedPosition = lerp(oldPosition, newPosition, i);
      updatePosition(pet, lerpedPosition.x, lerpedPosition.y);
      i += 0.02; // Adjust the step value 

      if (i >= 1) {
          clearInterval(interval);
      }
  }, 16); // Adjust the interval (in milliseconds)
}

function lerp(start, end, amt) {
  const lerpedX = (1 - amt) * start.x + amt * end.x;
  const lerpedY = (1 - amt) * start.y + amt * end.y;
  return {x: lerpedX, y: lerpedY };
}
//#endregion
// END OF POSITION/MOVING

//#region ---------------- FOOD/FEEDING ---------------
function spawnFood(foodElement, petElement) {
  console.log("Spawn food");
  document.body.appendChild(foodElement);
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;

  const randX = random(screenWidth);
  const randY = random(screenHeight);

  console.log("Food pos X = " + randX);
  console.log("Food pos Y = " + randY);

  foodElement.style.transform = `translate(${randX}px, ${randY}px)`;

  const foodPos = { x: randX, y: randY};
  const catPos = { x: position.x, y: position.y };

  let i = 0;
  const interval = setInterval(() => {
    const lerpedPosition = lerp(catPos, foodPos, i);
    updatePosition(petElement, lerpedPosition.x, lerpedPosition.y);
    i += 0.002;

    if (i >= 1) {
      clearInterval(interval);
      if (document.body.contains(foodElement)) document.body.removeChild(foodElement);
    }
  });
}

function textNodesUnder(el) {
  const children = []; // Type: Node[]
  const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  while(walker.nextNode()) {
      console.log("1");
      children.push(walker.currentNode);
      //walker.textContent = 'FEED ME';
  }
  return children
}

// function that changes all the text on screen to "FEED ME"
function feedMeText(texts) {
  console.log("FEED ME");
  texts.forEach(element => {
      if (element.textContent != "\n") element.textContent = "FEED ME";
  });
}

// function that removes text from a specific element
function eatTextInElement(ele) {
  element.textContent = "\n"
}

// function that eats the entire page
function eatAllText(texts) {
  texts.forEach(element => {
      element.textContent = "\n";
  });
}

function eatEntirePage() {
  document.querySelectorAll('*').forEach(element => {
      element.remove();
  });
}
//#endregion
// END OF FOOD/FEEDING

//#region ---------------- POPUP STUFF (i think) ------------------
function getExtensionID(callback) {
  chrome.runtime.sendMessage({ type: 'getExtensionID' }, (response) => {
      const extensionID = response;
      callback(extensionID);
  });
}

function constructFilePaths(extensionID) {
  const textFiles = [
      `chrome-extension://${extensionID}/text/gosling.txt`,
  ];

  const imageFiles = [
      `chrome-extension://${extensionID}/images/gosling.png`,
  ];

  return { textFiles, imageFiles };
}

function getRandomElement(array) {
  return array[Math.floor(Math.random() * array.length)];
}

function displayTextPopup(text) {
  const popup = document.createElement('div');
  popup.classList.add('popup');

  const closeButton = document.createElement('span');
  closeButton.classList.add('popup-close');
  closeButton.innerHTML = '&times;';
  closeButton.addEventListener('click', () => {
      document.body.removeChild(popup);
  });
  popup.appendChild(closeButton);

  const textElement = document.createElement('p');
  textElement.textContent = text;
  popup.appendChild(textElement);

  document.body.appendChild(popup);

  setTimeout(() => {
    if (document.body.contains(popup)) document.body.removeChild(popup);
  }, 5000);
}

function displayImagePopup(imagePath) {
  const popup = document.createElement('div');
  popup.classList.add('popup');

  const closeButton = document.createElement('span');
  closeButton.classList.add('popup-close');
  closeButton.innerHTML = '&times;';
  closeButton.addEventListener('click', () => {
      document.body.removeChild(popup);
  });
  popup.appendChild(closeButton);

  const imageElement = document.createElement('img');
  imageElement.src = imagePath;
  popup.appendChild(imageElement);

  document.body.appendChild(popup);

  setTimeout(() => {
    if (document.body.contains(popup)) document.body.removeChild(popup);
  }, 5000);
}

function displayFile(filePath) {
  if (filePath.endsWith('.txt')) {
    fetch(filePath)
        .then(response => response.text())
        .then(text => {
          displayTextPopup(text);
        })
        .catch(error => console.error('Error loading text file:', error));
  } else if (filePath.endsWith('.png')) {
    displayImagePopup(filePath);
  } else {
    console.error('Unsupported file format:', filePath);
  }
}
getExtensionID((extensionID) => {
  const { textFiles, imageFiles } = constructFilePaths(extensionID);

  function displayRandomFile() {
      const randomFilePath = getRandomElement([...textFiles, ...imageFiles]);
      displayFile(randomFilePath);
  }

  setInterval(displayRandomFile, 8000);
});
//#endregion
// END OF POPUP STUFF

//#region ----------------------- STATS -----------------------
function updateStats() {
    if (hunger >= 10 || attention >= 10) {
      hunger += 10
      attention += 10
    } else {
      if (hunger < 10) {
        attention += 10
      }
      if (attention < 10) {
        hunger += 10
      }
    }
}
//#endregion
// END OF STATS
   
//#region ---------------- SWATTING ----------------------
function checkSwat(mouseX, mouseY) {
    const swatRange = 50;
    const distance = Math.sqrt(Math.pow(mouseX - position.x, 2) + Math.pow(mouseY - position.y, 2));
    if (distance < swatRange && !isSwatting) {
        startSwatting();
    } else if (distance >= swatRange && isSwatting) {
        stopSwatting();
    }
}
    
function startSwatting() {
    const pet = document.querySelector('.meowware-pet');
    pet.classList.add('meowware-pet-swat');
    isSwatting = true;
}
    
function stopSwatting() {
    const pet = document.querySelector('.meowware-pet');
    pet.classList.remove('meowware-pet-swat');
    isSwatting = false;
}
//#endregion
// END OF SWATTING

//#region ------------------- KNOCKING ---------------------
document.addEventListener('mousemove', function(e) {
  const mouseX = e.clientX; // Mouse position X
  const mouseY = e.clientY; // Mouse position Y
  checkSwat(mouseX, mouseY);
  console.log("knocking is false!");
  WILL_KNOCK = false;
});
function check_if_knock() {
    if (WILL_KNOCK) {
        play_knock();
    }
    console.log("knocking is true");
    WILL_KNOCK = true;
}
function play_knock() {
    var audio = new Audio('audio/person-knocking-18474.mp3');
    audio.play();
}
//#endregion
// END OF KNOCKING